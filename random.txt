graph = {}
edge_set = set()
def add_node(node):
    if node in graph:
        print(f"Node '{node}' already exists! Please enter a different node.")
        return False
    graph[node] = []
    return True

def add_edge(u, v):
    edge = tuple((u, v))
    if edge in edge_set:
        print(f"Edge {u}-{v} already exists! Please enter a different edge.")
        return False
    if u not in graph or v not in graph:
        print("Both nodes must be added before connecting them with an edge.")
        return False
    graph[u].append(v)
    graph[v].append(u)
    edge_set.add(edge)
    return True

def bfs(start):
    visited = []
    queue = [start]
    print("BFS: ", end=" ")

    while queue:
        node = queue.pop(0)
        if node not in visited:
            print(node, end=" ")
            visited.append(node)
            for neighbor in graph[node]:
                if neighbor not in visited:
                    queue.append(neighbor)

def dfs(node, visited=None):
    if visited is None:
        visited = []
        print("\nDFS: ", end=" ")

    if node not in visited:
        print(node, end=" ")
        visited.append(node)
        for neighbor in graph[node]:
            dfs(neighbor, visited)

# --- Main Program ---
n = int(input("Enter number of nodes: "))
i = 0
while i < n:
    node = input(f"Enter node {i + 1}: ").strip()
    if add_node(node):
        i += 1

e = int(input("Enter number of edges: "))
for i in range(e):
    while True:
        u, v = input(f"Enter edge {i + 1} (two nodes): ").split()
        if add_edge(u, v):
            break
start = input("Enter starting node: ").strip()
if start in graph:
    bfs(start)
    dfs(start)
else:
    print("Starting node not found in the graph.")





exp9:
import matplotlib.pyplot as plt
from sklearn import datasets
from sklearn.cluster import KMeans
import pandas as pd
import numpy as np

# Load Iris dataset
iris = datasets.load_iris()

# Create DataFrame
X = pd.DataFrame(iris.data, columns=['Sepal_Length', 'Sepal_Width', 'Petal_Length', 'Petal_Width'])
y = pd.DataFrame(iris.target, columns=['Target'])

# Visualization of actual clusters
plt.figure(figsize=(14, 7))
colormap = np.array(['red', 'lime', 'black'])

# Plot Sepal features
plt.subplot(1, 2, 1)
plt.scatter(X.Sepal_Length, X.Sepal_Width, c=colormap[y.Target], s=40)
plt.title('Sepal - Real Classification')

# Plot Petal features
plt.subplot(1, 2, 2)
plt.scatter(X.Petal_Length, X.Petal_Width, c=colormap[y.Target], s=40)
plt.title('Petal - Real Classification')

# Apply KMeans Clustering
model = KMeans(n_clusters=3, random_state=0)
model.fit(X)

# Predicted labels
predY = np.choose(model.labels_, [0, 1, 2]).astype(np.int64)
print("Cluster Labels Assigned by KMeans:\n", predY)

# Visualizing the results of KMeans
plt.figure(figsize=(14, 7))

# Real classification
plt.subplot(1, 2, 1)
plt.scatter(X.Petal_Length, X.Petal_Width, c=colormap[y.Target], s=40)
plt.title('Petal - Real Classification')

# KMeans classification
plt.subplot(1, 2, 2)
plt.scatter(X.Petal_Length, X.Petal_Width, c=colormap[predY], s=40)
plt.title('Petal - KMeans Classification')

plt.show()
